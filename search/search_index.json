{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HCBench","text":""},{"location":"#hcbench-parsers","title":"\ud83e\uddec HCBench Parsers","text":"<p>Welcome to the HCBench Parser Suite \u2014 a unified framework for standardizing single-cell copy number alteration (CNA) outputs from multiple tools.</p> <p>Each parser converts heterogeneous output formats from different algorithms (CHISEL, Alleloscope, CNRein, SEACON, and SIGNALS) into a single consistent format suitable for downstream benchmarking and visualization.</p>"},{"location":"#overview","title":"\ud83d\udcd6 Overview","text":"Parser Input Type Input Format Output CHISEL <code>calls.tsv</code> + <code>mapping.tsv</code> Tab-delimited text Standardized CNA matrix + clone mapping Alleloscope <code>.rds</code> files R serialized data Standardized CNA matrix + clusters CNRein <code>CNReinPrediction.csv</code> CSV Standardized CNA matrix SEACON <code>calls.tsv</code> Tab-delimited text Standardized CNA matrix SIGNALS <code>hscn.rds</code> (exported to <code>.tsv</code>) Tab-delimited text Standardized CNA matrix <p>All parsers generate outputs in the same canonical structure, making it possible to directly compare results across tools in the HCBench benchmarking pipeline.</p>"},{"location":"#unified-output-format","title":"\u2699\ufe0f Unified Output Format","text":"<p>After parsing, every tool produces a standardized set of files in its designated output folder:</p> <pre><code>haplotype_combined.csv\nhaplotype_1.csv\nhaplotype_2.csv\nminor.csv\nmajor.csv\nminor_major.csv\nclusters.csv    # optional (for CHISEL / Alleloscope)\n</code></pre>"},{"location":"#main-file","title":"Main File","text":"<ul> <li><code>haplotype_combined.csv</code> \u2014 the core CNA matrix (regions \u00d7 cells)    Each entry represents the haplotype-specific copy number as <code>\"hap1|hap2\"</code>.</li> </ul>"},{"location":"#optional-files","title":"Optional Files","text":"<ul> <li><code>haplotype_1.csv</code>, <code>haplotype_2.csv</code> \u2014 per-haplotype copy number matrices.</li> <li><code>minor.csv</code> stores copy number values of the minor allele for each genomic segment and cell.</li> <li><code>major.csv</code> stores copy number values of the major allele.</li> <li><code>minor_major.csv</code> contains both numeric columns (<code>minor</code>, <code>major</code>) side by side for convenience in downstream analysis.</li> </ul>"},{"location":"#quick-start-example","title":"\ud83d\ude80 Quick Start Example","text":"<pre><code>from hcbench.parsers.chisel import ChiselParser\nfrom hcbench.parsers.alleloscope import AlleloscopeParser\nfrom hcbench.parsers.cnrein import CNReinParser\nfrom hcbench.parsers.seacon import SeaconParser\nfrom hcbench.parsers.signals import SignalsParser\n</code></pre>"},{"location":"#example-parsing-chisel-output","title":"Example: Parsing CHISEL Output","text":"<pre><code>chisel_input = \"/demo_output/chisel/calls/calls.tsv\"\nchisel_output = \"/output/chisel/\"\n\nparser = ChiselParser(chisel_input, chisel_output)\nparser.run()\n</code></pre>"},{"location":"#example-parsing-alleloscope-output","title":"Example: Parsing Alleloscope Output","text":"<pre><code>alleloscope_parser = AlleloscopeParser(\n    genotypes_rds_path=\"/demo_output/alleloscope/genotypes_all_Sample.rds\",\n    seg_table_rds_path=\"/demo_output/alleloscope/seg_table_all_Sample.rds\",\n    output_path=\"/output/alleloscope/\"\n)\nalleloscope_parser.run()\n</code></pre>"},{"location":"#documentation-index","title":"\ud83c\udf10 Documentation Index","text":"<ul> <li>CHISEL Parser</li> <li>Alleloscope Parser</li> <li>CNRein Parser</li> <li>SEACON Parser</li> <li>SIGNALS Parser</li> </ul>"},{"location":"gtbench/","title":"GTBench","text":"<p><code>GTBench</code> is an integrated benchmarking module for evaluating copy number alteration (CNA) results at both single-cell and clone levels.  It provides multiple submodules that assess copy number detection, classification, evolutionary stability, haplotype phasing, and clustering performance.</p>"},{"location":"gtbench/#overview-of-submodules","title":"Overview of Submodules","text":"Submodule Description Core Metrics <code>cndetect</code> Evaluates copy number (CN) detection accuracy RMSE, ACC, SCC <code>cnclass</code> Calculates CN state classification metrics AUROC, AUPRC, ACC, Precision, Recall, F1 <code>hccnchange</code> Evaluates correctness of CN changes between parent and child clones RMSE, ACC <code>hccnstable</code> Calculates evolutionary CN stability along the phylogenetic tree ACC <code>hconsetacc</code> Checks if CN events are detected at the correct branch of evolution ACC <code>hconsetcn</code> Evaluates accuracy of inferred parental CN RMSE, ACC <code>hcPhasing</code> Evaluates haplotype phasing accuracy Mismatch Error, Switch Error <code>mirrorsubclone</code> Evaluates mirror-subclone CNA detection accuracy RMSE, ACC <code>subdetect</code> Measures clustering accuracy across clones AMI, ARI"},{"location":"gtbench/#example-usage","title":"Example Usage","text":"<pre><code>from hcbench.gtbench.gtbench import GTBench\n\nbench = GTBench(output_dir=\"/path/to/output\")\n\nbench.cndetect(\n    tool_cna_files=[\"/path/to/signals/haplotype_combined.csv\",\n                    \"/path/to/seacon/haplotype_combined.csv\"],\n    cna_profile_file=\"/path/to/ground_truth_combined_cnv.csv\",\n    tool_names=[\"signals\", \"seacon\"]\n)\n</code></pre>"},{"location":"gtbench/#submodule-descriptions","title":"Submodule Descriptions","text":""},{"location":"gtbench/#1-cndetect","title":"1. cndetect","text":"<p>Calculates RMSE, ACC, and SCC for evaluating CN detection at the bin level.  It compares predicted CN profiles from different tools to the ground truth.</p> <p>Output: <code>bin_level_results.csv</code></p>"},{"location":"gtbench/#2-cnclass","title":"2. cnclass","text":"<p>Evaluates the accuracy of CN state classification across bins.  Supports both <code>acCNA</code> and <code>hcCNA</code> modes and computes AUROC, AUPRC, accuracy, precision, recall, and F1 score for each tool.</p> <p>Output: Categorized CNV CSV files and evaluation summary tables.</p>"},{"location":"gtbench/#3-hccnchange","title":"3. hccnchange","text":"<p>Determines whether CN changes between parent and child clones are correctly identified.  Evaluates the Root Mean Squared Error (RMSE) and Accuracy (ACC) for each tool.</p> <p>Output: <code>evolution_onset_CN_Change.csv</code></p>"},{"location":"gtbench/#4-hccnstable","title":"4. hccnstable","text":"<p>Computes Evolutionary CN Stability based on phylogenetic tree relationships between clones.  Requires both maternal/paternal CNA files and a <code>tree.newick</code> file describing clone hierarchy.</p> <p>Output: <code>evolution_cn_stability_acc.csv</code></p>"},{"location":"gtbench/#5-hconsetccc","title":"5. hconsetccc","text":"<p>Determines whether CN events are correctly detected at their first evolutionary branch.  This submodule evaluates accuracy (ACC) across DEL/DUP events.</p> <p>Output: <code>evolution_onset_acc.csv</code></p>"},{"location":"gtbench/#6-hconsetcn","title":"6. hconsetcn","text":"<p>Assesses whether parental CN states are correctly inferred during evolution.  Evaluates both RMSE and ACC.</p> <p>Output: <code>evolution_onset_parent_CN.csv</code></p>"},{"location":"gtbench/#7-hcphasing","title":"7. hcphasing","text":"<p>Quantifies haplotype phasing accuracy using two metrics:</p> <ul> <li>Mismatch Error: Fraction of individual loci where predicted haplotypes differ from the ground truth.</li> <li>Switch Error: Frequency of phase switches between consecutive loci.</li> </ul> <p>Output: <code>hcPhasing.csv</code></p>"},{"location":"gtbench/#8-mirrorsubclone","title":"8. mirrorsubclone","text":"<p>Evaluates accuracy of detecting mirror-subclone CNAs, using RMSE and ACC.  Mirror-subclones are pairs of subclones that exhibit complementary CNA patterns.</p> <p>Output: <code>mirror_subclone_result.csv</code></p>"},{"location":"gtbench/#9-subdetect","title":"9. subdetect","text":"<p>Calculates Adjusted Mutual Information (AMI) and Adjusted Rand Index (ARI) to measure clustering accuracy of predicted clone structures.  Each classification file should contain <code>cell_id</code> and <code>clone_id</code> columns.</p> <p>Output: <code>AMI_ARI_results.csv</code></p>"},{"location":"gtbench/#running-gtbench","title":"Running GTBench","text":"<p>Below is a complete example showing how to initialize and run all major GTBench modules.</p> <pre><code>from hcbench.gtbench.gtbench import GTBench\n\nbench = GTBench(output_dir=\"/path/to/results\")\n\n# 1. CN Detection Benchmark\nbench.cndetect(\n    tool_cna_files=[\n        \"/path/to/signals/haplotype_combined.csv\",\n        \"/path/to/seacon/haplotype_combined.csv\",\n    ],\n    cna_profile_file=\"/path/to/gt/ground_truth_combined_cnv.csv\",\n    tool_names=[\"signals\", \"seacon\"]\n)\n\n# 2. CN Classification Benchmark\nbench.cnclass(\n    tool_hap1_cna_files=[\n        \"/path/to/signals/haplotype_1.csv\",\n        \"/path/to/seacon/haplotype_1.csv\",\n    ],\n    tool_hap2_cna_files=[\n        \"/path/to/signals/haplotype_2.csv\",\n        \"/path/to/seacon/haplotype_2.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    profile_hap1_cna_file=\"/path/to/gt/haplotype_1.csv\",\n    profile_hap2_cna_file=\"/path/to/gt/haplotype_2.csv\",\n    type=\"hcCNA\"\n)\n\n# 3. CN Change Benchmark\nbench.hccnchange(\n    tool_hap1_cna_files=[\n        \"/path/to/signals/haplotype_1.csv\",\n        \"/path/to/seacon/haplotype_1.csv\",\n    ],\n    tool_hap2_cna_files=[\n        \"/path/to/signals/haplotype_2.csv\",\n        \"/path/to/seacon/haplotype_2.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    changes_file=\"/path/to/gt/changes.csv\",\n)\n\n# 4. CN Stability Benchmark\nbench.hccnstable(\n    tool_hap1_cna_files=[\n        \"/path/to/signals/haplotype_1.csv\",\n        \"/path/to/seacon/haplotype_1.csv\",\n    ],\n    tool_hap2_cna_files=[\n        \"/path/to/signals/haplotype_2.csv\",\n        \"/path/to/seacon/haplotype_2.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    changes_file=\"/path/to/gt/changes.csv\",\n    tree_file=\"/path/to/gt/tree.newick\",\n)\n\n# 5. CN Onset Accuracy Benchmark\nbench.hconsetacc(\n    tool_hap1_cna_files=[\n        \"/path/to/signals/haplotype_1.csv\",\n        \"/path/to/seacon/haplotype_1.csv\",\n    ],\n    tool_hap2_cna_files=[\n        \"/path/to/signals/haplotype_2.csv\",\n        \"/path/to/seacon/haplotype_2.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    changes_file=\"/path/to/gt/changes.csv\",\n)\n\n# 6. Parental CN Accuracy Benchmark\nbench.hconsetcn(\n    tool_hap1_cna_files=[\n        \"/path/to/signals/haplotype_1.csv\",\n        \"/path/to/seacon/haplotype_1.csv\",\n    ],\n    tool_hap2_cna_files=[\n        \"/path/to/signals/haplotype_2.csv\",\n        \"/path/to/seacon/haplotype_2.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    changes_file=\"/path/to/gt/changes.csv\",\n)\n\n# 7. Haplotype Phasing Accuracy\nbench.hcPhasing(\n    tool_hap1_cna_files=[\n        \"/path/to/signals/haplotype_1.csv\",\n        \"/path/to/seacon/haplotype_1.csv\",\n    ],\n    tool_hap2_cna_files=[\n        \"/path/to/signals/haplotype_2.csv\",\n        \"/path/to/seacon/haplotype_2.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    ground_truth_hap1_file=\"/path/to/gt/haplotype_1.csv\",\n    ground_truth_hap2_file=\"/path/to/gt/haplotype_2.csv\",\n)\n\n# 8. Mirror-Subclone Benchmark\nbench.mirrorsubclone(\n    tool_cna_files=[\n        \"/path/to/signals/haplotype_combined.csv\",\n        \"/path/to/seacon/haplotype_combined.csv\",\n    ],\n    tool_names=[\"signals\", \"seacon\"],\n    changes_file=\"/path/to/gt/mirrored_clones.csv\",\n)\n</code></pre>"},{"location":"parsers/alleloscope/","title":"Alleloscope Parser","text":"<p>This module provides <code>AlleloscopeParser</code>, specialized for parsing Alleloscope outputs and exporting standardized matrices and helper files used by hcbench workflows.</p> <p>Key features:</p> <ul> <li>Read Alleloscope RDS outputs (genotypes and segmentation table) and convert them into a unified haplotype level CNA matrix</li> <li>Optional region splitting by a user defined <code>bin_size</code></li> <li>Parse Alleloscope cluster assignments into a standardized <code>clusters.csv</code></li> <li>Export bin-level count matrices as <code>bin_counts.csv</code></li> <li>Convert a cellSNP-like VAF long table into sparse matrix outputs</li> </ul>"},{"location":"parsers/alleloscope/#quick-example","title":"\ud83d\ude80 Quick Example","text":""},{"location":"parsers/alleloscope/#parse-the-cna-matrix-from-rds","title":"Parse the CNA Matrix from RDS","text":"<pre><code>from hcbench.parsers.alleloscope import AlleloscopeParser\n\nallelo_output = \"/output/alleloscope/\"\ngenotypes_rds = \"/demo_output/alleloscope/genotypes.rds\"\nseg_table_rds = \"/demo_output/alleloscope/seg_table.rds\"\n\nalleloscope_parser = AlleloscopeParser(\n    output_path=allelo_output,\n    genotypes_rds_path=genotypes_rds,\n    seg_table_rds_path=seg_table_rds,\n    barcode_path=None,\n    bin_size=100000,          # set an integer to split regions, e.g. 100000\n    start_offset=1,         # shift start coordinate by +1 if needed\n)\n\nalleloscope_parser.run()\n</code></pre> <p>After running, the parser will read the two RDS files and save results to the output directory, typically containing files, for example:</p> <pre><code>/output/alleloscope/\n  haplotype_combined.csv\n  haplotype_1.csv\n  haplotype_2.csv\n  minor.csv\n  major.csv\n  minor_major.csv\n</code></pre>"},{"location":"parsers/alleloscope/#input-files","title":"\ud83d\udcc2 Input Files","text":"<p>The input directory of Alleloscope typically contains two <code>.rds</code> files and one optional cluster file:</p> <pre><code>demo_output/alleloscope/\n\u251c\u2500\u2500 genotypes_all_Sample.rds\n\u251c\u2500\u2500 seg_table_all_Sample.rds\n\u2514\u2500\u2500 cluster_assignment.csv   # optional\n</code></pre> <ul> <li><code>genotypes_all_Sample.rds</code> \u2014 contains the per-cell genotyping matrix.</li> <li><code>seg_table_all_Sample.rds</code> \u2014 contains segmentation information for genomic regions.</li> <li><code>cluster_assignment.csv</code> \u2014 optional file linking cells to inferred clones.</li> </ul> <p>These <code>.rds</code> files are generated by the R-based Alleloscope pipeline.  They must be readable using the Python package pyreadr.</p>"},{"location":"parsers/alleloscope/#output-files","title":"\ud83d\udce4 Output Files","text":"<p>After parsing, the following files are generated in the specified output directory:</p> <pre><code>haplotype_combined.csv\nclusters.csv          # only if cluster file provided\nhaplotype_1.csv       # if split_haplotype=True\nhaplotype_2.csv       # if split_haplotype=True\nminor.csv             # if split_haplotype=True\nmajor.csv             # if split_haplotype=True\nminor_major.csv       # if split_haplotype=True\n</code></pre> <ul> <li><code>haplotype_combined.csv</code> \u2014 the main CNA matrix (regions \u00d7 cells)    Each value represents the combined haplotype copy number in the form <code>\"hap1|hap2\"</code>.</li> <li><code>clusters.csv</code> \u2014 maps each cell to its corresponding clone ID, if available.</li> </ul>"},{"location":"parsers/alleloscope/#key-parameters","title":"\u2699\ufe0f Key Parameters","text":"Parameter Description Default <code>genotypes_rds_path</code> Path to <code>genotypes_all_Sample.rds</code>. \u2014 <code>seg_table_rds_path</code> Path to <code>seg_table_all_Sample.rds</code>. \u2014 <code>output_path</code> Directory to save parsed results. \u2014 <code>bin_size</code> Optional bin size to split large regions. <code>None</code> <code>add_chr_prefix</code> Whether to prepend <code>\"chr\"</code> to chromosome names. <code>True</code> <code>start_plus_one</code> Whether to convert <code>START</code> to 1-based coordinates. <code>True</code> <p>When <code>bin_size</code> is provided, large segments are automatically subdivided into equal bins.</p>"},{"location":"parsers/alleloscope/#example-usage","title":"\ud83d\ude80 Example Usage","text":"<pre><code>from hcbench.parsers.alleloscope import AlleloscopeParser\n\ngenotypes_rds = \"/demo_output/alleloscope/genotypes_all_Sample.rds\"\nseg_table_rds = \"/demo_output/alleloscope/seg_table_all_Sample.rds\"\noutput_dir = \"/output/alleloscope/\"\n\nalleloscope_parser = AlleloscopeParser(\n    genotypes_rds_path=genotypes_rds,\n    seg_table_rds_path=seg_table_rds,\n    output_path=output_dir,\n    bin_size=100000  # optional\n)\nalleloscope_parser.run()\n</code></pre> <p>If you also have a cluster file:</p> <pre><code>cluster_file = \"/demo_output/alleloscope/cluster.csv\"\nalleloscope_parser.get_cluster(cluster_file)\n</code></pre>"},{"location":"parsers/alleloscope/#generating-a-cluster-file-in-r","title":"\ud83e\uddec Generating a Cluster File in R","text":"<p>If you wish to generate the Alleloscope clustering file from your processed object in R,  you can use the following commands:</p> <pre><code>linplot = Lineage_plot(Obj_filtered = Obj_filtered, nSNP = 2000, nclust = 10)\nwrite.csv(linplot, file = \"cluster.csv\", row.names = TRUE)\n</code></pre> <p>This will create a <code>cluster.csv</code> file that can be used as input to <code>AlleloscopeParser.get_cluster()</code> in Python.</p>"},{"location":"parsers/chisel/","title":"CHISEL Parser","text":"<p>This module provides ChiselParser, specialized for parsing CHISEL outputs and exporting standardized matrices and helper files used by hcbench workflows.</p> <p>Key features:</p> <ul> <li>Run the existing  pipeline on CHISEL CNA tables</li> <li>Optional two-pass execution to export two different value columns into:</li> <li><code>clone_level/</code></li> <li><code>cell_level/</code></li> <li>Parse CHISEL cluster assignments into a standardized <code>clusters.csv</code></li> <li>Export bin-level count matrices as <code>bin_counts.csv</code></li> <li>Convert a cellSNP-like VAF long table into sparse matrix outputs</li> </ul>"},{"location":"parsers/chisel/#quick-example","title":"\ud83d\ude80 Quick Example","text":""},{"location":"parsers/chisel/#parse-the-cna-matrix","title":"\ud83e\uddec Parse the CNA Matrix","text":"<pre><code>from hcbench.parsers.chisel import ChiselParser\n\nchisel_input = \"/demo_output/chisel/calls/calls.tsv\"\nchisel_output = \"/output/chisel/\"\n\nchisel_parser = ChiselParser(chisel_input, chisel_output,value_cols=[\"HAP_CN_CLONE\", \"HAP_CN_CELL\"])\nchisel_parser.run()\n</code></pre> <p>After running, the parser will read <code>calls.tsv</code> and results are saved to the output directory, typically containing the following files:</p> <pre><code>/output/chisel/\n\u251c\u2500\u2500 clone-level/\n\u2502   \u2514\u2500\u2500 haplotype_combined.csv\n\u2502   \u2514\u2500\u2500 haplotype_1.csv       \n\u2502   \u2514\u2500\u2500 haplotype_2.csv       \n\u2502   \u2514\u2500\u2500 minor.csv             \n\u2502   \u2514\u2500\u2500 major.csv             \n\u2502   \u2514\u2500\u2500 minor_major.csv\n\u251c\u2500\u2500 cell-level/\n\u2502   \u2514\u2500\u2500 haplotype_combined.csv\n\u2502   \u2514\u2500\u2500 haplotype_1.csv       \n\u2502   \u2514\u2500\u2500 haplotype_2.csv       \n\u2502   \u2514\u2500\u2500 minor.csv             \n\u2502   \u2514\u2500\u2500 major.csv             \n\u2502   \u2514\u2500\u2500 minor_major.csv   \n</code></pre> <ul> <li><code>haplotype_combined.csv</code> \u2014 main CNA matrix (regions \u00d7 cells).   Each value represents the combined haplotype copy number in the form <code>\"hap1|hap2\"</code>.</li> </ul>"},{"location":"parsers/chisel/#parse-the-cluster-file","title":"\ud83e\uddec Parse the Cluster File","text":"<p>If you have a CHISEL cluster mapping file (commonly named <code>mapping.tsv</code>), you can parse it separately using the new <code>get_cluster()</code> method:</p> <pre><code>cluster_file = \"/demo_output/chisel/clones/mapping.tsv\"\nchisel_parser.get_cluster(cluster_file)\n</code></pre> <p>An example of <code>mapping.tsv</code>:</p> <pre><code>#CELL    CLUSTER    CLONE\nAAACCTGAGAAGGACA    3233    Clone3233\nAAACCTGAGATCTGCT    1484    Clone1484\nAAACCTGAGTAATCCC    1924    None\nAAACCTGAGTGCTGCC    3233    Clone3233\n\n</code></pre> <p>After running this command, the following standardized file will be created:</p> <pre><code>/output/chisel/\n\u2514\u2500\u2500clusters.csv\n</code></pre> <p>with content:</p> <pre><code>cell_id,clone_id\nAAACCTGAGAAGGACA,3233\nAAACCTGAGATCTGCT,1484\nAAACCTGAGTAATCCC,1924\n</code></pre>"},{"location":"parsers/chisel/#parse-the-bin-counts-matrix","title":"\ud83e\uddec Parse the bin counts matrix","text":"<pre><code>chisel_parser.get_bin_counts()\n</code></pre> <p>After running this command, the following standardized file will be created:</p> <pre><code>/output/chisel/\n\u2514\u2500\u2500bin_counts.csv\n</code></pre>"},{"location":"parsers/chisel/#parse-the-vaf-sparse-matrices","title":"\ud83e\uddec Parse the VAF sparse matrices","text":"<pre><code>chisel_parser.get_VAF_matrix(\n    vaf_file_path=\"/demo_output/chisel/baf/baf.tsv\",\n    min_dp=3,\n    min_cells=10,\n)\n</code></pre> <p>After running this command, the following standardized file will be created:</p> <pre><code>/output/chisel/\n\u251c\u2500\u2500 VAF/\n\u2502   \u2514\u2500\u2500cellSNP_*.mtx\n</code></pre>"},{"location":"parsers/chisel/#initialization","title":"\u2699\ufe0f Initialization","text":"<pre><code>ChiselParser(\n    input_path: str,\n    output_path: str,\n    barcode_path: str | None = None,\n    value_cols: list[str] | tuple[str, str] | None = None,\n    **kwargs\n)\n</code></pre> <p>Parameters</p> <ul> <li><code>input_path</code></li> </ul> <p>Path to the CHISEL CNA output table (long format), the output directory of CHISEL typically looks like this:</p> <p><code>demo_output/chisel/   \u251c\u2500\u2500 calls/   \u2502   \u2514\u2500\u2500 calls.tsv</code></p> <p>An example of <code>calls.tsv</code>:</p> <p><code>#CHR  START   END CELL    NORM_COUNT  COUNT   RDR A_COUNT B_COUNT BAF CLUSTER HAP_CN  CORRECTED_HAP_CN   chr1  0   1000000 AAACAGGTACAT    16269   1590    0.7594  76  67  0.4685  55  1|1 1|1   chr1  0   1000000 AAATTTGCCTTA    16269   3003    1.3324  74  195 0.7249  55  6|2 6|2   chr1  0   1000000 AACACATCCATC    16269   1587    0.9759  78  78  0.5 55  1|1 1|1</code></p> <p>The required columns are:</p> <p><code>#CHR, START, END, CELL, CORRECTED_HAP_CN</code></p> <p>\u200b   Please ensure these column names are spelled exactly as shown.</p> <ul> <li> <p><code>output_path</code>    Base output directory.    If <code>value_cols</code> contains two columns, <code>ChiselParser</code> will automatically write to:</p> </li> <li> <p><code>{output_path}/clone_level</code></p> </li> <li> <p><code>{output_path}/cell_level</code></p> </li> <li> <p><code>barcode_path</code> (optional)    Path to a barcode mapping file used to remap cell.    Mapping is applied in:</p> </li> <li> <p>CNA table</p> </li> <li>cluster table</li> <li> <p>counts table</p> </li> <li> <p><code>value_cols</code> (optional)    Enables two-pass execution. Must be a <code>list</code>/<code>tuple</code> of length 2, e.g.:</p> </li> </ul> <pre><code>  value_cols=['CORRECTED_HAP_CN','HAP_CN']\n</code></pre> <p>Behavior:</p> <ul> <li><code>value_cols[0]</code> \u2192 written under <code>clone_level/</code></li> <li><code>value_cols[1]</code> \u2192 written under <code>cell_level/</code></li> </ul> <p>If not provided, the parser runs once using the default <code>value_col = \"HAP_CN\"</code>.</p>"},{"location":"parsers/chisel/#core-methods","title":"\ud83e\udde0 Core Methods","text":""},{"location":"parsers/chisel/#chiselparserrun","title":"<code>ChiselParser.run()</code>","text":"<ul> <li>Legacy mode (default): if <code>value_cols</code> is not provided (or only one column is configured), it runs once:</li> <li>Uses <code>self.value_col</code> (default: <code>HAP_CN</code>)</li> <li>Writes into <code>output_path</code></li> <li>Two-pass mode: if <code>value_cols</code> has length 2, it runs twice:</li> <li><code>self.value_col = value_cols[0]</code> \u2192 <code>output_path/clone_level</code></li> <li><code>self.value_col = value_cols[1]</code> \u2192 <code>output_path/cell_level</code></li> </ul>"},{"location":"parsers/chisel/#chiselparserget_clustercluster_file_path","title":"<code>ChiselParser.get_cluster(cluster_file_path)</code>","text":"<p>Parses a CHISEL cluster mapping file and writes a standardized CSV.</p> <p>Input</p> <ul> <li><code>cluster_file_path</code>: TSV file containing at least:</li> <li><code>#CELL</code></li> <li><code>CLUSTER</code></li> </ul> <p>Output</p> <p>Writes to:</p> <ul> <li><code>{self.output_path}/clusters.csv</code></li> </ul> <p>CSV schema:</p> column meaning cell_id cell identifier (possibly remapped) clone_id CHISEL cluster/clone label"},{"location":"parsers/chisel/#chiselparserget_bin_counts","title":"<code>ChiselParser.get_bin_counts()</code>","text":"<p>Creates a region-by-cell wide matrix of per-bin counts.</p> <p>Output</p> <p>Writes to:</p> <ul> <li><code>{self.output_path}/bin_counts.csv</code></li> </ul> <p>This is a wide matrix:</p> <ul> <li>rows: <code>region</code> (e.g., <code>chr1:1000-2000</code>)</li> <li>columns: cells</li> <li>values: counts</li> </ul>"},{"location":"parsers/chisel/#chiselparserget_vaf_matrixvaf_file_path-output_pathnone-min_dp1-min_cells1-prefixcellsnp","title":"<code>ChiselParser.get_VAF_matrix(vaf_file_path, output_path=None, min_dp=1, min_cells=1, prefix=\"cellSNP\")</code>","text":"<p>Converts a cellSNP-like VAF long table into sparse matrix outputs using <code>long_to_mtx()</code>.</p> <p>Input format</p> <p><code>vaf_file_path</code> must be a tab-separated file with no header and exactly 5 columns:</p> column index meaning 0 chromosome 1 genomic position 2 cell identifier 3 allele A count 4 allele B count <p>Parameters</p> <ul> <li><code>output_path</code> (optional)</li> <li>If provided: outputs under <code>{output_path}/VAF</code></li> <li>Else: outputs under <code>{self.output_path}/VAF</code></li> <li><code>min_dp</code></li> <li>filter low depth (typically <code>Acount + Bcount</code>)</li> <li><code>min_cells</code></li> <li>filter sites supported by too few cells</li> <li><code>prefix</code></li> <li>output file prefix (default: <code>cellSNP</code>)</li> </ul> <p>Output</p> <p>Creates a <code>VAF/</code> directory containing files:</p> <p><code>.../VAF/   cellSNP_*.mtx   ...</code></p>"},{"location":"parsers/cnrein/","title":"CNRein Parser","text":""},{"location":"parsers/cnrein/#input-files","title":"\ud83d\udcc2 Input Files","text":"<p>The output directory of CNRein typically includes a single main file that records per-cell haplotype-specific copy number information:</p> <pre><code>demo_output/cnrein/finalPrediction\n\u2514\u2500\u2500 CNReinPrediction.csv\n</code></pre> <ul> <li><code>CNReinPrediction.csv</code> \u2014 main output file containing haplotype-level copy number information for each cell across all genomic regions.</li> </ul> <p>An example of <code>CNReinPrediction.csv</code>:</p> <pre><code>Cell barcode,Chromosome,Start,End,Haplotype 1,Haplotype 2\nTN1_3_S1_C85,1,800001,20100000,2,0\nTN1_3_S1_C85,1,20100001,29200000,3,1\nTN1_3_S1_C85,1,29200001,33100000,3,1\nTN1_3_S1_C85,1,33100001,34900000,3,1\n</code></pre> <p>The required columns are:</p> <pre><code>Chromosome, Start, End, Cell barcode, Haplotype 1, Haplotype 2\n</code></pre> <p>The parser combines the two haplotype columns (<code>Haplotype 1</code> and <code>Haplotype 2</code>) into a single unified field called <code>HAP_CN</code>,  formatted as <code>\"hap1|hap2\"</code>, for example <code>\"2|0\"</code>.</p>"},{"location":"parsers/cnrein/#output-files","title":"\ud83d\udce4 Output Files","text":"<p>After parsing, the following file is generated in the specified output directory:</p> <pre><code>haplotype_combined.csv\n</code></pre> <ul> <li><code>haplotype_combined.csv</code> \u2014 the standardized CNA matrix (regions \u00d7 cells).    Each entry represents the combined haplotype state of a cell in <code>\"Haplotype 1|Haplotype 2\"</code> format.</li> </ul> <p>If the <code>split_haplotype=True</code> option is used in the parser base class,  additional per-haplotype and major/minor copy number matrices will also be generated automatically:</p> <pre><code>haplotype_1.csv\nhaplotype_2.csv\nminor.csv\nmajor.csv\nminor_major.csv\n</code></pre>"},{"location":"parsers/cnrein/#key-parameters","title":"\u2699\ufe0f Key Parameters","text":"Parameter Description Default <code>chrom_col</code> Column name for chromosome. <code>\"Chromosome\"</code> <code>start_col</code> Column name for region start. <code>\"Start\"</code> <code>end_col</code> Column name for region end. <code>\"End\"</code> <code>cell_col</code> Column name for cell barcode. <code>\"Cell barcode\"</code> <code>value_col</code> Column name for the combined haplotype CN value. <code>\"HAP_CN\"</code> <code>start_plus_one</code> Whether to convert 0-based to 1-based coordinates. <code>False</code> <code>add_chr_prefix</code> Whether to ensure <code>\"chr\"</code> prefix on chromosome names. <code>True</code>"},{"location":"parsers/cnrein/#example-usage","title":"\ud83d\ude80 Example Usage","text":"<pre><code>from hcbench.parsers.cnrein import CNReinParser\n\ncnrein_input = \"/demo_output/cnrein/finalPrediction/CNReinPrediction.csv\"\ncnrein_output = \"/output/cnrein/\"\n\ncnrein_parser = CNReinParser(\n    input_path=cnrein_input,\n    output_path=cnrein_output\n)\n\ncnrein_parser.run()\n</code></pre> <p>This will read <code>CNReinPrediction.csv</code>, merge <code>Haplotype 1</code> and <code>Haplotype 2</code> into the <code>HAP_CN</code> column,  and save a standardized file named:</p> <pre><code>haplotype_combined.csv\nhaplotype_1.csv       # if split_haplotype=True\nhaplotype_2.csv       # if split_haplotype=True\nminor.csv             # if split_haplotype=True\nmajor.csv             # if split_haplotype=True\nminor_major.csv       # if split_haplotype=True\n</code></pre> <p>in your output directory.</p>"},{"location":"parsers/seacon/","title":"SEACON Parser","text":""},{"location":"parsers/seacon/#input-files","title":"\ud83d\udcc2 Input Files","text":"<p>The output directory of SEACON typically includes a single main file containing copy number information for all cells:</p> <pre><code>demo_output/seacon/\n\u2514\u2500\u2500 calls.tsv\n</code></pre> <ul> <li><code>calls.tsv</code> \u2014 the primary SEACON output file containing inferred copy number (CN) states per cell and genomic region.</li> </ul> <p>An example of <code>calls.tsv</code>:</p> <pre><code>cell    chrom   start   end CN\nclone9_cell6    chr1    5000001 10000000    0,2\nclone9_cell6    chr1    15000001    20000000    0,2\nclone9_cell6    chr1    20000001    25000000    0,2\nclone9_cell6    chr1    25000001    30000000    0,2\n</code></pre> <p>The required columns are:</p> <pre><code>chrom, start, end, cell, CN\n</code></pre> <p>Each entry in the <code>CN</code> column may contain comma-separated allele-specific copy numbers (e.g. <code>\"0,2\"</code>).  The parser automatically converts these values to a standardized <code>\"hap1|hap2\"</code> format (e.g. <code>\"0|2\"</code>).</p>"},{"location":"parsers/seacon/#output-files","title":"\ud83d\udce4 Output Files","text":"<p>After parsing, the following file is generated in the specified output directory:</p> <pre><code>haplotype_combined.csv\n</code></pre> <ul> <li><code>haplotype_combined.csv</code> \u2014 standardized CNA matrix (regions \u00d7 cells).    Each value represents the haplotype-level copy number in the format <code>\"hap1|hap2\"</code>.</li> </ul> <p>If <code>split_haplotype=True</code> is enabled in the base class,  the parser will also produce additional derived matrices:</p> <pre><code>haplotype_1.csv\nhaplotype_2.csv\nminor.csv\nmajor.csv\nminor_major.csv\n</code></pre>"},{"location":"parsers/seacon/#key-parameters","title":"\u2699\ufe0f Key Parameters","text":"Parameter Description Default <code>chrom_col</code> Column name for chromosome. <code>\"chrom\"</code> <code>start_col</code> Column name for region start. <code>\"start\"</code> <code>end_col</code> Column name for region end. <code>\"end\"</code> <code>cell_col</code> Column name for cell ID. <code>\"cell\"</code> <code>value_col</code> Column name for copy number value. <code>\"CN\"</code> <code>start_plus_one</code> Whether to shift start coordinates by +1. <code>False</code> <code>add_chr_prefix</code> Whether to enforce <code>\"chr\"</code> prefix on chromosome names. <code>False</code>"},{"location":"parsers/seacon/#example-usage","title":"\ud83d\ude80 Example Usage","text":"<pre><code>from hcbench.parsers.seacon import SeaconParser\n\nseacon_input = \"/demo_output/seacon/calls.tsv\"\nseacon_output = \"/output/seacon/\"\n\nseacon_parser = SeaconParser(\n    input_path=seacon_input,\n    output_path=seacon_output\n)\nseacon_parser.run()\n</code></pre> <p>After running, the parser will read <code>calls.tsv</code>,  convert <code>CN</code> values from <code>\"x,y\"</code> to <code>\"x|y\"</code>,  and save the standardized file:</p> <pre><code>haplotype_combined.csv\n</code></pre> <p>in your output directory.</p>"},{"location":"parsers/signals/","title":"SIGNALS Parser","text":""},{"location":"parsers/signals/#input-files","title":"\ud83d\udcc2 Input Files","text":"<p>The output directory of SIGNALS typically contains the R object <code>hscn.rds</code>, which stores haplotype-specific copy number data.</p> <pre><code>demo_output/signals/output/\n\u251c\u2500\u2500 hscn.rds\n\u2514\u2500\u2500 hscn_data.tsv   # exported for Python parser\n</code></pre> <ul> <li><code>hscn.rds</code> \u2014 main SIGNALS output file (R serialized object).</li> <li><code>hscn_data.tsv</code> \u2014 exported tab-delimited file containing per-cell phased copy number states.</li> </ul> <p>Because the SIGNALS parser in HCBench operates in Python,  you need to first export the data component from the RDS file into a <code>.tsv</code> file using R.</p>"},{"location":"parsers/signals/#exporting-hscn_datatsv-from-r","title":"\ud83e\uddec Exporting hscn_data.tsv from R","text":"<p>Run the following R code to extract and save the <code>hscn$data</code> component:</p> <pre><code>mnt &lt;- \"/demo_output/signals/output/\"\n\nhscn &lt;- readRDS(\"/demo_output/signals/hscn.rds\")\n\n# Export the data component\nwrite.table(\n  hscn$data,\n  file = paste0(mnt, \"hscn_data.tsv\"),\n  sep = \"\\t\",\n  quote = FALSE,\n  row.names = FALSE\n)\n</code></pre> <p>This will produce the file <code>hscn_data.tsv</code>, which is then used as input for the parser.</p>"},{"location":"parsers/signals/#output-files","title":"\ud83d\udce4 Output Files","text":"<p>After parsing, results are saved in the specified output directory:</p> <pre><code>haplotype_combined.csv\n</code></pre> <ul> <li><code>haplotype_combined.csv</code> \u2014 standardized CNA matrix (regions \u00d7 cells).    Each entry represents the phased haplotype-specific copy number state of a cell.</li> </ul> <p>If <code>split_haplotype=True</code> is enabled in the base class,  additional files such as <code>haplotype_1.csv</code>, <code>haplotype_2.csv</code>, and <code>minor_major.csv</code> will also be generated.</p>"},{"location":"parsers/signals/#key-parameters","title":"\u2699\ufe0f Key Parameters","text":"Parameter Description Default <code>chrom_col</code> Column name for chromosome. <code>\"chr\"</code> <code>start_col</code> Column name for region start. <code>\"start\"</code> <code>end_col</code> Column name for region end. <code>\"end\"</code> <code>cell_col</code> Column name for cell identifier. <code>\"cell_id\"</code> <code>value_col</code> Column name for the haplotype-phased CN value. <code>\"state_AS_phased\"</code> <code>start_plus_one</code> Whether to convert 0-based to 1-based coordinates. <code>False</code> <code>add_chr_prefix</code> Whether to ensure chromosome names begin with <code>\"chr\"</code>. <code>True</code>"},{"location":"parsers/signals/#example-usage","title":"\ud83d\ude80 Example Usage","text":"<pre><code>from hcbench.parsers.signals import SignalsParser\n\nsignals_input = \"/demo_output/signals/output/hscn_data.tsv\"\nsignals_output = \"/output/signals/\"\n\nsignals_parser = SignalsParser(\n    input_path=signals_input,\n    output_path=signals_output\n)\nsignals_parser.run()\n</code></pre> <p>After running, the parser reads the exported <code>hscn_data.tsv</code>, extracts the <code>\"state_AS_phased\"</code> column as the haplotype-level copy number signal, and saves the standardized file:</p> <pre><code>haplotype_combined.csv\n</code></pre> <p>in your chosen output directory.</p>"},{"location":"parsers/signals/#example-of-hscn_datatsv","title":"\ud83e\udde9 Example of hscn_data.tsv","text":"<p>An example of the exported file may look like:</p> <pre><code>chr start   end reads   copy    state   cell_id alleleA alleleB totalcounts BAF state_min   A   B   state_AS_phased state_AS    LOH phase   state_phase state_BAF\n1   5000001 10000000    34762   NA  2   clone1_cell1    677 193 870 0.22183908045977    1   1   1   1|1 1|1 NO  Balanced    Balanced    0.5\n1   20000001    25000000    34200   NA  2   clone1_cell1    639 222 861 0.257839721254355   1   1   1   1|1 1|1 NO  Balanced    Balanced    0.5\n1   30000001    35000000    42510   NA  2   clone1_cell1    807 203 1010    0.200990099009901   1   1   1   1|1 1|1 NO  Balanced    Balanced    0.5\n</code></pre> <p>Each row corresponds to one genomic bin in a given single cell.</p> <p>The *required columns* are:</p> <p>```</p> <p>chr,start,end,cell_id,state_AS_phased</p> <p>```</p>"}]}